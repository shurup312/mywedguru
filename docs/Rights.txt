Права в контроллерах определяются как поведение. То есть это сторонний класс, который перед выполнением экшена перехватывает управление и проверяет,
может ли код выполняться дальше. В простом понимании контроллер реализует шаблон проектирования "наблюдатель". Все наблюдатели регистрируются массивом в контроллере.
И перед выполнением экшена контроллера всем им по очереди передает управление. Если на каком-то этапе один из наблюдателей не пропускает выполнение кода дальше, то
он просто выбрасывает исключение. В нашем случае класс проверки прав в случае недостаточности прав выбрасывает исключение с кодом 403.
Подключение поведения (наблюдателя) происходит в контроллере в методе behaviors, который должен вернуть массив поведений. ПРимер определения поведения для проверки прав
	public function behaviors()
	{
		return [
			'access' => [
				'class' => AccessBehavior::className(),
				'rights'=> [User::ADMIN_RIGHTS],
				'only'  => ['admin', 'index'],
				'callback'=>function(){
					return time()%2==1;
				},
				'ip'=>['127.0.0.1'],
				'rules' => [
					[
						'actions' => ['admin'],
						'rights'  => [User::COMPANY_REALTOR],
						'callback'=>function(){
							return time()%2==1;
						},
					],
				]
			]
		];
	}
Ключ "access" ни на что не влияет и может содержать любое имя, главное чтобы он нормально описывал своим названием, что за поведение он содержит.
Далее обязательный параметр - класс для проверки прав (в общем случае - класс поведения).
Остальные настройки не обязательные для класс проверки прав. Но рассмотрим их поближе, чтобы понимать, что они делают.
Параметр 'rights' устанавливает в целом доступ к текущему контроллеру. Это наименее приоритетный параметр. Он учитывается только если не будет передпределен
более высокоприоритетными правилами (коллбэк, детальные правила, см. далее)
Параметр only представляет собой массив названий экшенов (без префикса 'action', то есть для экшена actionIndex массив должен содержать просто запись 'index'),
которые доступны для отображения. То есть если у этом массиве какой-то экнеш не указан, то он ни при каких условиях не будет отображен. При любых правилах он
будет возвращать исключение 403 (недостаточно прав).
Параметр 'callback' позволяет задавать пользовательскую функцию, которая возвращает true или false. На основании этого результата позволяется либо запрещается
выполнение экшена. Таким образом, если необходимо задать сложную логику для проверки дальнейшей возможности выполнения экшена, то ее можно описать тут.
Как пример использования - все экшены контроллера доступны только пользователю с определенным id. Или только по субботам, или, как в нашем случае,
только по нечетны секундам.
Следуюий параметр - массив rules. Он содержит в себе массивы более детаьных правил.
В нашем примере в rules только один массив. В этом массиве указывается список экшенов, для которых этот массив задает детализацию прав. 'rights' -
это список прав, необходимых для доступа к экшенам указанным в 'actions'. 'callback', как и в случае с родительским массивом, содержит пользовательскую функцию.
Она возвращает true или false. И выполняет ту же задачу что и параметр 'callback' в родительском массиве. И еще один параметр Для примера,
если указан массив
return [
    'access' => [
        'class' => AccessBehavior::className(),
        'rules' => [
            [
                'actions' => ['admin'],
                'rights'  => [User::ADMIN],
            ],
        ]
    ]
];
То это значит, что в контроллере всем будут доступны все экшены кроме экшена 'admin', для него добавлено специальное правило, которое гласит, что оно распространяется
на пользователей с правами User::GUEST и оно разрешается только ему.
И еще один метод ограничения  - это блокировка по ip. Все ip, указанные в массиве 'ip', будут блокироваться, то есть класс будет возвращать исключение 403.

Так как в параметрах может быть задано сразу все вышеперечисленное, то рассмотрим приоритет проверок:
1. вначале выполняется проверка, что задан параметр "only", и, если он задан, то ищется название метода в нем. Если метод отсутствует в only, то 403 ошибка.
2. Если задан параметр 'rights' и пользователь не попадает по правам, то 403 ошибка.
то пользователю выдается сообщение, что доступ запрещен.
2. Далее проверяется, задан ли параметр callback, и, если задан, то берется результат его выполнения. Если там false, то 403 ошибка.
3. Если задан набор правил rules, то ищется массив с правилами, под который попадал бы текущий экшен (параметр actions в массиве правил).
4. Если такой набор правил найден, то сравниваются права текущего пользователя и прав из массива "rights". Если прав пользователя в массив енет, то 403 ошибка.
5. Проверяем, задана ли пользовательская функция 'callback', если она задана и возвращает false, то 403 ошибка.
7. Последний и самый приоритетный этап проверки - проверка ip на наличие в массиве ip, если этот массив задан, то если в нем присутствует IP текущего подключениея, то 403 ошибка.
