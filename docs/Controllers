Контроллер - один из основных составляющих компонентов, на которых строится модуль.
Когда вы пишете в адресной строке
/admin/index,
движок ищет модуль admin и в нем ищет метод actionIndex. Внутри этого метода находится все, что отнсится к вызыванной странице.
Как понятно из названия метода, сам метод должен называться начиная с префикса action и далее camelCase стилем идет название экшена (то, что передано в URL'е).
Давайте потренируемся,
/adm/edit
ищет модуль
adm, и с нем метод actionEdit.
На самом деле, это не единственный метод, который может быть использован.
Менее распространенный, но поддерживаемый вариант - методы get{Имя}, post{Имя}.
Каждый из них вызывается, когда вы отправляете get или post запрос. Причем, эти методы ищутся в контроллере в первую очередь, и, если найдены,
то обрабатывают запрос именно они.
Итак, потренируемся,
вы отправляете запрос на страницу
/adm/add POST методом из формы
движок вначале ищет метод postAdd, а если метод не найден, то ищет actionAdd.
Теперь мы немного стали понимать, как прописать в контроллере методы для страниц.
Еще один вариант обрабоки запроса - использование классов-обработчиков для экшенов. Он несколько более громоздкий, но в определенных
ситуациях позволяет написать один раз экшен и подключать его к разным контроллерам экономя время. Для примера, CRUD операции по сути всегда
во всех контроллерах одинаковы. Именно через написание класса-обработчика мы можем описать один раз эти 4 экшена и далее
просто подключать к нужным контроллерам. Более подробно можно почитать в документе Actions,
тут лишь напишу, что экшены прописываются в методе actions в контроллере.
Для примера
public function actions(){
    return [
        'index'=>[
            'class'=>TestAction::className(),
        ]
    ];
}
таким образом при запросе метода index в контроллере обработчиком будет выступать класс TestAction.
Хочется отметить, что контроллер вначале ищет экшены внутри себя, а уж если они не описаны, то только в этом случае "смотрит" в actions-массив.
Таким образом методы, описывающие экшены в контроллере являются более приоритетными.
Мы разобрались, как описывать методы в контроллере.
Далее следует сказать, что метод может принимать параметры
Для примера
public function actionAdd($id){
    ...
}
Такой метод будет обрабатывать уже не запросы
/adm/add, а запросы
/adm/add/{что-то-как-значение-параметра-id}
И, как вы понмаете, из URL {что-то-как-значение-параметра-id} будет передано как значение параметра id в метод.
Тут стоит обратить внимание, что параметр в данном случае указан обязательный, поэтому при том, что метод
public function actionAdd($id){
    ...
}
и описан, /adm/add возвратит ошибку, так как не передан необходимый параметр. Чтобы этого избежать, можно сделать параметр необязательным.
public function actionAdd($id='какое-то значение'){
    ...
}
Тогда и запрос
/adm/add
И запрос
/adm/add/{тут-что-то-еще}
будет прекрасно обрабатываться экшеном.
Для классов-обработчиков экшеном правило точно так же должно выполняться.
Класс-обработчик экшена TestAction Должен содержать метод
public function run($id=false)
чтобы все работало корректно
(ну или конечно же просто вариант
public function run())

Внутри метода контроллер вызывает сервисы (смотрим документацию по сервисам) и далее вызывает на рендеринг view файл.
результат своей работы метод должен возвращать как return. Никаких echo и die (exit) в методе контроллера не допускается.
Более подробно про view файлы читайте документ по вьюхам.
Для рендеринга доступны методы
$this->render() и $this->renderPartial()
первый возвращает контент отрендеренного view файла с дизайном, вторй - только контент отрендеренного файла.
Таким образом хотите вывести страницу? - используем вариант render, хотите отрендерить часть страницы для последующей
вставки в другое месте или ответ ajax, который в дизайне не нуждается - используете renderPartial.

Сами методы принимают в качестве параметра имя файла и параметры для view-файла.
По умолчанию ищется вначалу файл по тому пути, который указан в качестве параметра (если вы указали полный путь к
файлу, что в контроллерах обычно не используется), а далее, если файл не найден (в случае когда вы указали просто имя файла, без пути),
файл ищется в папке view, которая находится рядом с контроллером.
Давайте потренируемся
$this->renderPartial(dirname(__FILE__).'asset.php')
будет искать файл c именем asset.php в папке самого контроллера, не найдеи его и вернет исключение.
$this->renderPartial('asset.php') будет искать в папке view, которая назодится радом с контроллером в папке модуля.

Внутрь view-файла можно передавать параметы.
Как пример
$this->render('index.php',['ver'=>'0.5', 'isTrue'=>true]);
Теперь, описывая файл, Вам будут достыпны переменные $ver и $isTrue с переданными значениями.
Хорошим тоном считается во view-файле указывать доступные переменные через phpDoc.
Для примера, если во view-файл была передана переменная $message, то вначаеле самого view-файла необходимо написать
 /**
  * @var {type} $varName
  */

Допустим для приведенного выше примера
/**
 * @var string $ver
 * @var bool $isTrue
 */
Такой подсказкой вы и себе и своим товарищам упростите жизнь. Неплохо, если переменная будет тут же содержать описание, например
/**
 * @var string $message Сообщение о текущем статусе пользователя
 */
