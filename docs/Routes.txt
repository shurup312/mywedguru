В системе появилась возможность устанавливать правила маршрутизации. Это значит, что пользователь вводит адрес
/adm и система по умолчанию вызывает Controller внутри adm модуля. А точней его экшен actionIndex. Но нередко бывает
нужда поменять такое поведение, и сделать возможность передать обработку адреса не тем контроллером, который должен быть по умолчанию.
Допустим, пользователь вводит /index.phar, а мы должны обработать это дело контроллером /user/status/Controller.php и в нем экшеном actionUpdate.
По хорошему в таком случае
/index.phar
должен обрабатываться так, как если бы это был адрес
/user/status/update.
Чтобы это реализовать, мы прописываем правило маршрутизации в system\defines.php в массиве "paths".
Для нашей ситуации это правило будет выглядеть так
'paths'   => [
    '/index.phar' => '/user/status/update'
]
Помимо простого статического изменения адреса с одного на другой доступно применение регулярных выражений.
Допустим, мы можем все адреса, в которых вначале идет /adm, а далее цифры перенаправлять куда-то. Вот пример реализации
'paths'   => [
    '/adm/<id:\w>' => '/adm'
]
Таким образом мы регулярное выражение оборачиваем в <>, которое так же включает в себя имя данного правила, а через ":" идет само регулярное выражение.
Значение, выбранное поименованным правилом можно использовать и в значении массива, а не только в ключе.
Пример реализации
'paths'   => [
    '/adm/<id:\w>' => '/adm2/<id>'
]
Это значит, что адрес, взятый для примера /adm/3 будет обрабатываться так, как если бы мы ввели адрес /adm2/3. То есть выбранное из реального адреса значение
3 было сохранено в именованное правило "id", а далее реальный адрес для движка сайта был подменен по правилу на '/adm2/<id>', где в свою очередь вместо <id>
было подставленно выбранное значение 3, и в итоге адрес для движка стал /adm2/3.

Порядок выполнения правил "сверху вниз". То есть если найдено правило рутинга, удовлетворяющее текущему URL'у, то оно и будет применено,
дальнйший перебор правил будет прекращен.
Чтобы стало более понятно, о чем идет речь, приведу пример
'paths'   => [
    '/adm/<id:\w>' => '/url1'
    '/adm/3' => '/url2'
]

При вводе пользователем адреса /adm/3 будет найдено первое правило
'/adm/<id:\w>' => '/url1'
и запрос будет обработан так, как если бы был введен адрес /url1.
Но из правила ниже мы видим, что разработчик предполагал, что адрес '/adm/3' должен был обрабатываться как '/url2'. И чтобы выполнение правил было именно таким,
как ожидает разработчик, более частные правила надо писать выше более общих.
Таким образом просто написав
'paths'   => [
    '/adm/3' => '/url2'
    '/adm/<id:\w>' => '/url1'
]
разработчик бы добился именно того, чего он ожидал.
