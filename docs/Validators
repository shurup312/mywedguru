Реализованы валидаторы. Они могут быть применены к любом объекту, который является дочерним для \system\core\Object.
Таким образом валидировать можно формы, модели или что-то еще свое.
Для описания набора проверок создается папка validators в модуле, а в ней создается класс с имененем {Что-то, что описывает, что делает валидатор}Validator.php
Например
TestModelValidator.php, то есть валидатор модели Test.
Класс валидации должен быть дочерним от класса system\core\validators\ModelValidator.
Класс должен реализовывать метод rules с описание набора правил. Вначале приведу пример описания, а затем разберемся, что там может быть
return [
    [
        ['title'],
        'between',
        'min'       => 3,
        'max'       => 1000,
        'inclusive' => true
    ],
    [
        ['title'],
        'lessThan',
        'max'       => -5,
        'inclusive' => true
    ],
    [
        ['id', 'title'],
        'greaterThan',
        'min'       => 20,
        'inclusive' => true
    ],
    [
        ['id', 'title'],
        'stringLength',
        'min'       => 4,
        'max'       => 12,
    ],
    [
        ['title'],
        'between',
        'min'       => 2,
        'max'       => 49,
        'inclusive' => false,
        'scenario'  => 'save'
    ],
    [
        'id',
        'inArray',
        'haystack' => [
            1,
            3,
            5
        ],
    ],
    [
        'title',
        'notEmpty',
    ],
    [
        'id',
        'regex',
        'pattern' => '/[a-z]+?/',
        'message' => 'Ерунда какая-то',
    ],
];

Как мы видим, метод возвращаетм массив массивов, где каждый вложенный массив описывает оно правило валидации.
Первый параметр может быть или строкой или массивом. Он содержит Поля в передаваемой модели, которые будут валидироваться. В данном примере подразумевается,
что будет валидироваться модель с полями title, id.
Следующий параметр указывает на название правила, по которому должно валидироваться поле. Список доступных правил и их применение будет описано ниже.
Следующий параметр, который можети присутствовать - это scenario. Это параметр, который указывает, что по правилу, описанному в текущем подмассиве ваидация
будет происходить не всегда, а только в определенных случаях. Описание механизма ниже, но приведу пример применения текущего функционала. Допустим у нас есть модель
пользователя. Мы ее можем валидировать при добавлении нового пользователя и при редактировании пользователя. Указание пароля в редактировании может быть
необзательным, потому что при редактировании мы можем не менять пароль, а вот при добавлении пароль обяхателен. Значит один класс валидации должен себя вести по
разному в разных ситуациях, чтобы не писать два класса для валидации. Параметр scenario и делает эту настройку - выполненеи правила валидации не всегда,
а в определенных случаях.
По умолчанию выдается стандартное сообщение валидатора, но вы можете заменить сообщение ошибки на нужное вам, для этого еще один доступен параметр "message".

Разберем, какие же правила валидации нам доступны.
1. Проверка на непустое значение - правило notEmpty
Применение: просто указываем это название проверки для поля/полей и все.
Пример:
...
[
    'title',
    'notEmpty',
],
...

2. Проверка на то, что число меньше, чем N - рпавило lessThan
Параметрами необходимо указать
(integer|float) max - максимум, который может принимать текущее значение
(boolean) inclusive - включается ли указанное максимальное значение в список допустимых или нет, другими словами если указано true, то валидатор
считает <=, если же не указано, то <
Пример:
...
[
    ['title'],
    'lessThan',
    'max'       => -5,
    'inclusive' => true.
],
...

3. Проверка на то, что число больше, чем N - правило greaterThan
Параметрами необходимо указать
(integer|float) min минимум, который может принимать текущее значение
(boolean) inclusive - включается ли указанное минимальное в список допустимых или нет, другими словами если указано true, то валидатор
считает >=, если же не указано, то >
Пример:
...
[
    ['id', 'title'],
    'greaterThan',
    'min'       => 20,
    'inclusive' => true,
],
...

4. Проверка на то, что число между N и M - правило between
Параметрами необходимо указать
(integer|float) min минимум, который может принимать текущее значение
(integer|float) max максимум, который может принимать текущее значение
(boolean) inclusive - включаются ли указанные границы в список допустимх или нет, другими словами если указано true,
то валидатор считает >= и <=, если же не указано, то > и <
Пример:
...
[
    'between',
    'min'       => 3,
    'max'       => 1000,
    'inclusive' => true],
...

5. Проверка длины строки, правило - stringLength
Параметрами необходимо указать
'min'       => 4,
'max'       => 12,
(integer|float) min минимальна длина строки
(integer|float) max максимальная длина строки
Пример:
...
[
    ['id', 'title'],
    'stringLength',
    'min'       => 4,
    'max'       => 12,
],
...

6. Проверка, что значение попадает в список допустимых - правило inArray
Параметрами необходимо указать
(array) haystack - массив доступных значений
Пример:
...
[
    ['id', 'title'],
    'inArray',
    'haystack' => [
        1,
        3,
        5
    ],
],
...

7. Проверка значения регулярным выражением - правило regex
Параметрами необходимо указать
(string) pattern шаблон регулярного выражения
Пример:
...
[
    'id',
    'regex',
    'pattern' => '/[a-z]+?/',
],
...

Сценарии валидации
Как и говорилось выше, в некоторых случаях необходимо применять не все валидаторы. Для того, чтобы это сделать, мы можем
определенному правилу указать, что он должен применяться не всегда, а только если у нас выбран определенный сценарий. Допустим,
пароль проверяем при сценарии save, а вот в остальных случаях не применяем его. Само по себе название сценария - любое слово,
главное чтобы оно нормально описывало то, под что этот сценарий.
перед валидацией задать сценарий.

Сам процесс валидации
Итак, мы описали класс валидатора, теперь необходимо ему скомить данные для валидации
1. Вызывает конструктор класса валидации передавая объект для валидации
$validator = new TestModelValidator($form);
2. задание текущего сценария валидации, если это необходимо
$validator->setScenario('save');
3. Проверка объекта
$isValid = $validator->isValid()
4. Получение списка ошибок по полям, если объект не провел проверку
$errors = $validator->getErrors();

итого, пример кода
$form = new AddressForm('address');
$errors = [];
if($get = App::request()->get('address')){
    $form->load($get);
    $validator = new TestModelValidator($form);
    $validator->setScenario('save');
    if(!$validator->isValid()){
        $form->setErrors($validator->getErrors());
    }
}
return $this->render('form.php', [
    'form'   => $form,
]);

